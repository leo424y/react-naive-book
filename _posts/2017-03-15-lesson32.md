---
layout: post
title: 動手實現 Redux（三）：純函數（Pure Function）簡介
description: React.js 小書是一個開源、免費、專業、簡單的 React.js 線上教程。提煉實戰經驗中基礎的、重要的、頻繁的知識進行重點講解，讓你能用最少的精力深入瞭解實戰中最需要的 React.js 知識。
tags: [react.js,web,props,state,javascript]
---

<ul style='font-size: 14px;'>
  <li>
    作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha" target="_blank">鬍子大哈</a>
  </li>
  <li>
    原文連結：<a href="http://huziketang.com/books/react{{ page.url }}"> http://huziketang.com/books/react{{ page.url }} </a>
  </li>
  <li>轉載請註明出處，保留原文連結和作者資訊。</li>
</ul>

（本文未稽覈）

我們接下來會繼續優化我們的 `createStore` 的模式，讓它使我們的應用程式獲得更好的效能。

但在開始之前，我們先用一節的課程來介紹一下一個函數語言程式設計裡面非常重要的概念 —— 純函數（Pure Function）。

簡單來說，*一個函數的返回結果只依賴於它的參數，並且在執行過程裡面沒有副作用，我們就把這個函數叫做純函數*。這麼說肯定比較抽象，我們把它掰開來看：

1.  函數的返回結果只依賴於它的參數。
2. 函數執行過程裡面沒有副作用。

## 函數的返回結果只依賴於它的參數

```javascript
const a = 1
const foo = (b) => a + b
foo(2) // => 3
```

`foo` 函數不是一個純函數，因為它返回的結果依賴於外部變數 `a`，我們在不知道 `a` 的值的情況下，並不能保證 `foo(2)` 的返回值是 3。雖然 `foo` 函數的程式碼實現並沒有變化，傳入的參數也沒有變化，但它的返回值卻是*不可預料*的，現在 `foo(2)` 是 3，可能過了一會就是 4 了，因為 a 可能發生了變化變成了 2。

```javascript
const a = 1
const foo = (x, b) => x + b
foo(1, 2) // => 3
```

現在 `foo` 的返回結果只依賴於它的參數 `x` 和 `b`，`foo(1, 2)` 永遠是 3。今天是 3，明天也是 3，在伺服器跑是 3，在客戶端跑也 3，不管你外部發生了什麼變化，`foo(1, 2)` 永遠是 3。只要 `foo` 程式碼不改變，你傳入的參數是確定的，那麼 `foo(1, 2)` 的值永遠是*可預料的*。

這就是純函數的第一個條件：*一個函數的返回結果只依賴於它的參數*。

## 函數執行過程沒有副作用
一個函數執行過程對產生了*外部可觀察的變化*那麼就說這個函數是有副作用的。

我們修改一下 `foo`：

```javascript
const a = 1
const foo = (obj, b) => {
  return obj.x + b
}
const counter = { x: 1 }
foo(counter, 2) // => 3
counter.x // => 1
```

我們把原來的 `x` 換成了 `obj`，我現在可以往裡面傳一個物件進行計算，計算的過程裡面並不會對傳入的物件進行修改，計算前後的 `counter` 不會發生任何變化，計算前是 1，計算後也是 1，它現在是純的。但是我再稍微修改一下它：

```javascript
const a = 1
const foo = (obj, b) => {
  obj.x = 2
  return obj.x + b
}
const counter = { x: 1 }
foo(counter, 2) // => 4
counter.x // => 2
```

現在情況發生了變化，我在 `foo` 內部加了一句 `obj.x = 2`，計算前 `counter.x` 是 1，但是計算以後 `counter.x` 是 2。`foo` 函數的執行對外部的 `counter` 產生了影響，它產生了*副作用*，因為它修改了外部傳進來的物件，現在它是不純的。

但是你在函數內部構建的變數，然後進行資料的修改不是副作用：

```javascript
const foo = (b) => {
  const obj = { x: 1 }
  obj.x = 2
  return obj.x + b
}
```

雖然 `foo` 函數內部修改了 obj，但是 `obj` 是內部變數，外部程式根本觀察不到，修改 `obj` 並不會產生外部可觀察的變化，這個函數是沒有副作用的，因此它是一個純函數。

除了修改外部的變數，一個函數在執行過程中還有很多方式產生*外部可觀察的變化*，比如說呼叫 DOM API 修改頁面，或者你傳送了 Ajax 請求，還有呼叫 `window.reload` 重新整理瀏覽器，甚至是 `console.log` 往控制檯列印資料也是副作用。

純函數很嚴格，也就是說你幾乎除了計算資料以外什麼都不能幹，計算的時候還不能依賴除了函數參數以外的資料。

## 總結
一個函數的返回結果只依賴於它的參數，並且在執行過程裡面沒有副作用，我們就把這個函數叫做純函數。

為什麼要煞費苦心地構建純函數？因為純函數非常“靠譜”，執行一個純函數你不用擔心它會幹什麼壞事，它不會產生不可預料的行為，也不會對外部產生影響。不管何時何地，你給它什麼它就會乖乖地吐出什麼。如果你的應用程式大多數函數都是由純函陣列成，那麼你的程式測試、偵錯起來會非常方便。
